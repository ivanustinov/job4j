When deserializing, constructors are not called: the object is simply restored as it is
what he was.
 Pay attention to what is happening with the state of the object inherited from
superclass's.After all, it is determined not only by the values of the fields defined in it, but
also inherited from the superclass. Serializable subtype takes on such
responsibilityif the superclass has a default constructor that will be called
during deserialization. Otherwise you receive an exception an invalidclassexception?.
In the process of deserializing the field of parent classes that do not implement the Serializable interface?,
initiated by calling a constructor with no parameters. The fields of the serialized class will be
restored from a stream.
If you want to control the progress of serialization and recovery of an object, use
the Externalizable interface?. In this case, only authentication is automatically written to the stream
class's. Save and restore all information must be the class itself-through writeExternal methods()
and readExternal () methods ?the Externalizable interface?.
When you serialize the object first checks to support the Externalizable interface?. If
has the check been completed, the writeExternal () method is called?. If the object does not support Externalizable?,
but it implements Serializable?, standard serialization is used. At restoration
Externalizable object instance is created via a call to public no-arg constructor. Then
is the readExternal () method called?. The Serializable objects are restored by reading
from the stream the ObjectInputStream?.
When managing the serialization process, it does not always make sense to refer to the implementation
the Externalizable interface. If you do not want to save and restore the field, it is enough
declare it with the transient modifier?. Similarly, it is possible to act without
skip the preservation of the object, the deserialization of which still will not make sense –
for example, a network connection.

When deserializing, constructors are not called: the object is simply restored as it is
what he was. Pay attention to what is happening with the state of the object inherited from
superclass's. After all, it is determined not only by the values of the fields defined in it, but
also inherited from the superclass. Serializable subtype takes on such
responsibility if the superclass has a default constructor that will be called
during deserialization. Otherwise you receive an exception an invalidclassexception?.
In the process of deserializing the field of parent classes that do not implement the Serializable interface?,
initiated by calling a constructor with no parameters. The fields of the serialized class will be
restored from a stream.
If you want to control the progress of serialization and recovery of an object, use
the Externalizable interface?. In this case, only authentication is automatically written to the stream
class's. Save and restore all information must be the class itself-through writeExternal methods()
and readExternal () methods ?the Externalizable interface?.
When you serialize the object first checks to support the Externalizable interface?. If
has the check been completed, the writeExternal () method is called?. If the object does not support Externalizable?,
but it implements Serializable?, standard serialization is used. At restoration
Externalizable object instance is created via a call to public no-arg constructor. Then
is the readExternal () method called?. The Serializable objects are restored by reading
from the stream the ObjectInputStream?.
When managing the serialization process, it does not always make sense to refer to the implementation
the Externalizable interface. If you do not want to save and restore the field, it is enough
declare it with the transient modifier?. Similarly, it is possible to act without
skip the preservation of the object, the deserialization of which still will not make sense –
for example, a network connection.